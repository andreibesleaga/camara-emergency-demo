# CAMARA Location Services Emergency Demo

Minimal full-stack demo: Node.js backend + React/Leaflet frontend + MCP bridge + mock generator,
using camara-sdk and camara-mcp libraries.

Quick start

1. Copy .env.example to .env and set USE_MOCK=true
2. npm install
3. npm run build:full
4. npm run start -> open [http://localhost:8080](http://localhost:8080)

## Configuration

The `.env.example` file now documents all the inputs required to switch from mock data to live CAMARA Network APIs:

- **Global CAMARA settings** (`CAMARA_BASE_URL`, `CAMARA_SANDBOX_CONTRACT_ID`, `CAMARA_OPERATOR_NAME`, `CAMARA_SCOPE`, `CAMARA_SCOPES`).
- **OAuth/OpenID Connect** endpoints and credentials (`CAMARA_OAUTH_*`) to support client-credential exchanges against an operator sandbox.
- **Per product overrides** (`CAMARA_POPULATION_DENSITY_*`, `CAMARA_REGION_DEVICE_COUNT_*`, `CAMARA_DEVICE_LOCATION_*`, `CAMARA_ALERTS_*`) including usage mode flags (`synchronous`, `asynchronous`, `subscription`) and callback endpoints when a webhook is required.
- **Callback defaults** (`CAMARA_CALLBACK_BASE_URL`, `CAMARA_CALLBACK_AUTH_HEADER`) for operators that push events to the application.
- **Orange developer placeholders** (`ORANGE_APPLICATION_ID`, `ORANGE_CLIENT_ID`, `ORANGE_CLIENT_SECRET`, `ORANGE_TOKEN_URL`, `ORANGE_SCOPES`) matching the Network APIs Playground documentation.

Population density uses `ngeohash` cells returned by CAMARA to build the heatmap. Device location remains subscription-driven in live mode; the backend surfaces instructive errors until a webhook sink is configured.

Leave `USE_MOCK=true` until valid sandbox credentials are supplied; once all required variables are filled, set `USE_MOCK=false` to start wiring the live CAMARA flows.

Railway

- Build: npm run build:full
- Start: npm run start
- Vars: from .env.example

Endpoints

- GET /api/location/device/:deviceId
- POST /api/density/snapshot
- GET /api/density/flow/:areaId
- POST /api/alerts/rules
- GET /api/alerts/rules
- DELETE /api/alerts/rules/:id
- GET /api/alerts/stream (SSE)
- POST /api/routing/plan
- POST /api/mcp/invoke

## AI assistant & MCP usage

The camara-sdk repository ships with the generated [CAMARA MCP server](/camara-sdk/packages/mcp-server) so you can give AI agents direct access to the same telecom APIs used by the demo front end.

1. Install the server (no build step required):

	 ```bash
	 npx -y camara-mcp@latest --client=claude --tools=dynamic
	 ```

2. Export the CAMARA bearer keys or token exchange variables that correspond to the products you want the assistant to access. At minimum populate the notification keys generated by your operator sandbox, for example:

	 ```bash
	 export CAMARA_POPULATION_DENSITY_DATA_NOTIFICATIONS_API_KEY="..."
	 export CAMARA_REGION_DEVICE_COUNT_NOTIFICATIONS_API_KEY="..."
	 # add additional CAMARA_*_NOTIFICATIONS_API_KEY values as needed
	 ```

	 If your operator issues OAuth credentials instead of static keys, reuse the same environment variables documented earlier (`CAMARA_OAUTH_*`, `CAMARA_*_SCOPES`, etc.) before starting the server.

3. Point your MCP-compatible client (Cursor, Claude desktop, VS Code agents, etc.) at the server. A basic `modelContextProtocol.json` entry looks like:

	 ```json
	 {
		 "mcpServers": {
			 "camara_sdk_api": {
				 "command": "npx",
				 "args": ["-y", "camara-mcp", "--client=cursor", "--tools=dynamic"],
				 "env": {
					 "CAMARA_POPULATION_DENSITY_DATA_NOTIFICATIONS_API_KEY": "..."
				 }
			 }
		 }
	 }
	 ```

4. Inside the assistant, use the `list_api_endpoints`, `get_api_endpoint_schema`, and `invoke_api_endpoint` tools (exposed automatically when `--tools=dynamic` is set) to discover and execute CAMARA endpoints. You can narrow scope with command-line filters such as `--resource=populationdensitydata` or load prepared subsets with `--tool` / `--no-tool` flags.

Need to run the MCP server remotely? Launch it with `npx camara-mcp --transport=http --port 3030` and configure your client to target `http://localhost:3030`, optionally passing the same filters as URL query parameters.
